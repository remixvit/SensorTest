ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 1


   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 4
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"I2C_I2C_INT.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.I2C_I2C_ISR,"ax",%progbits
  18              		.align	1
  19              		.global	I2C_I2C_ISR
  20              		.code	16
  21              		.thumb_func
  22              		.type	I2C_I2C_ISR, %function
  23              	I2C_I2C_ISR:
  24              	.LFB0:
  25              		.file 1 ".\\Generated_Source\\PSoC4\\I2C_I2C_INT.c"
   1:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** /*******************************************************************************
   2:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * File Name: I2C_I2C_INT.c
   3:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * Version 3.0
   4:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *
   5:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * Description:
   6:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *  This file provides the source code to the Interrupt Service Routine for
   7:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *  the SCB Component in I2C mode.
   8:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *
   9:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * Note:
  10:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *
  11:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** ********************************************************************************
  12:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * Copyright 2013-2015, Cypress Semiconductor Corporation.  All rights reserved.
  13:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * You may use this file only in accordance with the license, terms, conditions,
  14:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * disclaimers, and limitations in the end user license agreement accompanying
  15:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * the software package with which this file was provided.
  16:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *******************************************************************************/
  17:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  18:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** #include "I2C_PVT.h"
  19:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** #include "I2C_I2C_PVT.h"
  20:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** #include "cyapicallbacks.h"
  21:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  22:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  23:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** /*******************************************************************************
  24:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * Function Name: I2C_I2C_ISR
  25:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** ********************************************************************************
  26:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *
  27:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * Summary:
  28:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *  Handles the Interrupt Service Routine for the SCB I2C mode.
  29:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *
  30:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * Parameters:
  31:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *  None
  32:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 2


  33:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * Return:
  34:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *  None
  35:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *
  36:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *******************************************************************************/
  37:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** CY_ISR(I2C_I2C_ISR)
  38:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** {
  26              		.loc 1 38 0
  27              		.cfi_startproc
  28              	.LVL0:
  29 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
  30              		.cfi_def_cfa_offset 24
  31              		.cfi_offset 3, -24
  32              		.cfi_offset 4, -20
  33              		.cfi_offset 5, -16
  34              		.cfi_offset 6, -12
  35              		.cfi_offset 7, -8
  36              		.cfi_offset 14, -4
  39:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     uint32 diffCount;
  40:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     uint32 endTransfer;
  41:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  42:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** #ifdef I2C_I2C_ISR_ENTRY_CALLBACK
  43:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     I2C_I2C_ISR_EntryCallback();
  44:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** #endif /* I2C_I2C_ISR_ENTRY_CALLBACK */
  45:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     
  46:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** #if (I2C_I2C_CUSTOM_ADDRESS_HANDLER_CONST)
  47:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     uint32 response;
  48:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  49:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     response = I2C_I2C_ACK_ADDR;
  50:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** #endif /* (I2C_I2C_CUSTOM_ADDRESS_HANDLER_CONST) */
  51:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  52:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     endTransfer = 0u; /* Continue active transfer */
  53:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  54:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     /* Calls customer routine if registered */
  55:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     if(NULL != I2C_customIntrHandler)
  37              		.loc 1 55 0
  38 0002 AD4B     		ldr	r3, .L72
  39 0004 1B68     		ldr	r3, [r3]
  40 0006 002B     		cmp	r3, #0
  41 0008 00D0     		beq	.L2
  56:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     {
  57:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_customIntrHandler();
  42              		.loc 1 57 0
  43 000a 9847     		blx	r3
  44              	.LVL1:
  45              	.L2:
  58:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     }
  59:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  60:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     if(I2C_CHECK_INTR_I2C_EC_MASKED(I2C_INTR_I2C_EC_WAKE_UP))
  46              		.loc 1 60 0
  47 000c AB4B     		ldr	r3, .L72+4
  48 000e 1B68     		ldr	r3, [r3]
  49 0010 DB07     		lsl	r3, r3, #31
  50 0012 02D5     		bpl	.L3
  61:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     {
  62:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         /* Mask-off after wakeup */
  63:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_SetI2CExtClkInterruptMode(I2C_NO_INTR_SOURCES);
  51              		.loc 1 63 0
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 3


  52 0014 0022     		mov	r2, #0
  53 0016 AA4B     		ldr	r3, .L72+8
  54 0018 1A60     		str	r2, [r3]
  55              	.L3:
  64:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     }
  65:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  66:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     /* Master and Slave error tracking:
  67:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     * Add the master state check to track only the master errors when the master is active or
  68:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     * track slave errors when the slave is active or idle.
  69:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     * A special MMS case: in the address phase with misplaced Start: the master sets the LOST_ARB a
  70:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     * slave BUS_ERR. The valid event is LOST_ARB comes from the master.
  71:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     */
  72:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     if(I2C_CHECK_I2C_FSM_MASTER)
  56              		.loc 1 72 0
  57 001a AA4B     		ldr	r3, .L72+12
  58 001c 1A78     		ldrb	r2, [r3]
  59 001e 9206     		lsl	r2, r2, #26
  60 0020 01D4     		bmi	.L4
  61              	.LVL2:
  62              	.L9:
  52:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  63              		.loc 1 52 0
  64 0022 0021     		mov	r1, #0
  65 0024 23E0     		b	.L5
  66              	.LVL3:
  67              	.L4:
  73:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     {
  74:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         #if(I2C_I2C_MASTER)
  75:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         {
  76:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* INTR_MASTER_I2C_BUS_ERROR:
  77:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * A misplaced Start or Stop condition occurred on the bus: complete the transaction.
  78:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The interrupt is cleared in I2C_FSM_EXIT_IDLE.
  79:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
  80:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_MASTER_MASKED(I2C_INTR_MASTER_I2C_BUS_ERROR))
  68              		.loc 1 80 0
  69 0026 A84A     		ldr	r2, .L72+16
  52:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  70              		.loc 1 52 0
  71 0028 0021     		mov	r1, #0
  72              		.loc 1 80 0
  73 002a 1068     		ldr	r0, [r2]
  74 002c C005     		lsl	r0, r0, #23
  75 002e 06D5     		bpl	.L6
  81:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
  82:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_mstrStatus |= (uint16) (I2C_I2C_MSTAT_ERR_XFER |
  76              		.loc 1 82 0
  77 0030 C024     		mov	r4, #192
  78 0032 A648     		ldr	r0, .L72+20
  79 0034 A400     		lsl	r4, r4, #2
  80 0036 0188     		ldrh	r1, [r0]
  81 0038 2143     		orr	r1, r4
  82 003a 0180     		strh	r1, [r0]
  83              	.LVL4:
  83:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                          I2C_I2C_MSTAT_ERR_BUS_ERROR);
  84:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  85:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
  84              		.loc 1 85 0
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 4


  85 003c 0121     		mov	r1, #1
  86              	.LVL5:
  87              	.L6:
  86:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
  87:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  88:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* INTR_MASTER_I2C_ARB_LOST:
  89:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The MultiMaster lost arbitrage during transaction.
  90:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * A Misplaced Start or Stop condition is treated as lost arbitration when the master dr
  91:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The interrupt source is cleared in I2C_FSM_EXIT_IDLE.
  92:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
  93:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_MASTER_MASKED(I2C_INTR_MASTER_I2C_ARB_LOST))
  88              		.loc 1 93 0
  89 003e 1268     		ldr	r2, [r2]
  90 0040 D207     		lsl	r2, r2, #31
  91 0042 06D5     		bpl	.L7
  94:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
  95:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_mstrStatus |= (uint16) (I2C_I2C_MSTAT_ERR_XFER |
  92              		.loc 1 95 0
  93 0044 9020     		mov	r0, #144
  94 0046 A149     		ldr	r1, .L72+20
  95              	.LVL6:
  96 0048 8000     		lsl	r0, r0, #2
  97 004a 0A88     		ldrh	r2, [r1]
  98 004c 0243     		orr	r2, r0
  99 004e 0A80     		strh	r2, [r1]
 100              	.LVL7:
 101 0050 01E0     		b	.L8
 102              	.LVL8:
 103              	.L7:
  96:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                          I2C_I2C_MSTAT_ERR_ARB_LOST);
  97:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  98:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
  99:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 100:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 101:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             #if(I2C_I2C_MULTI_MASTER_SLAVE)
 102:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 103:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* I2C_MASTER_CMD_M_START_ON_IDLE:
 104:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 * MultiMaster-Slave does not generate start, because Slave was addressed.
 105:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 * Pass control to slave.
 106:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 */
 107:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(I2C_CHECK_I2C_MASTER_CMD(I2C_I2C_MASTER_CMD_M_START_ON_IDLE))
 108:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 109:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_mstrStatus |= (uint16) (I2C_I2C_MSTAT_ERR_XFER |
 110:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                              I2C_I2C_MSTAT_ERR_ABORT_XFER);
 111:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 112:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
 113:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 114:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 115:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             #endif
 116:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 117:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* The error handling common part:
 118:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * Sets a completion flag of the master transaction and passes control to:
 119:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             *  - I2C_FSM_EXIT_IDLE - to complete transaction in case of: ARB_LOST or BUS_ERR.
 120:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             *  - I2C_FSM_IDLE      - to take chance for the slave to process incoming transaction.
 121:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 122:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(0u != endTransfer)
 104              		.loc 1 122 0
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 5


 105 0052 0029     		cmp	r1, #0
 106 0054 E5D0     		beq	.L9
 107              	.LVL9:
 108              	.L8:
 123:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 124:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Set completion flags for master */
 125:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_mstrStatus |= (uint16) I2C_GET_I2C_MSTAT_CMPLT;
 109              		.loc 1 125 0
 110 0056 0121     		mov	r1, #1
 111 0058 0220     		mov	r0, #2
 112 005a 1A78     		ldrb	r2, [r3]
 113 005c 9B4C     		ldr	r4, .L72+20
 114 005e 0A40     		and	r2, r1
 115 0060 821A     		sub	r2, r0, r2
 116 0062 2088     		ldrh	r0, [r4]
 117 0064 0243     		orr	r2, r0
 118 0066 92B2     		uxth	r2, r2
 119 0068 2280     		strh	r2, [r4]
 126:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 127:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #if(I2C_I2C_MULTI_MASTER_SLAVE)
 128:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 129:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     if(I2C_CHECK_I2C_FSM_ADDR)
 130:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 131:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Start generation is set after another master starts accessing Slave.
 132:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * Clean-up master and turn to slave. Set state to IDLE.
 133:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 134:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         if(I2C_CHECK_I2C_MASTER_CMD(I2C_I2C_MASTER_CMD_M_START_ON_IDLE))
 135:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 136:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_I2C_MASTER_CLEAR_START;
 137:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 138:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER; /* Pass control to Slave */
 139:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 140:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Valid arbitration lost on the address phase happens only when: master LO
 141:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * slave BUS_ERR is cleared. Only in that case set the state to IDLE without
 142:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 143:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else if((!I2C_CHECK_INTR_SLAVE_MASKED(I2C_INTR_SLAVE_I2C_BUS_ERROR))
 144:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                && I2C_CHECK_INTR_MASTER_MASKED(I2C_INTR_MASTER_I2C_ARB_LOST))
 145:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 146:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER; /* Pass control to Slave */
 147:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 148:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else
 149:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 150:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             endTransfer = 0u; /* Causes I2C_FSM_EXIT_IDLE to be set below */
 151:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 152:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 153:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         if(0u != endTransfer) /* Clean-up master to proceed with slave */
 154:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 155:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_CLEAR_TX_FIFO; /* Shifter keeps address, clear it */
 156:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 157:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_DISABLE_MASTER_AUTO_DATA_ACK; /* In case of reading disable autoACK
 158:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 159:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Clean-up master interrupt sources */
 160:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_ClearMasterInterruptSource(I2C_INTR_MASTER_ALL);
 161:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 162:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Disable data processing interrupts: they have to be cleared before *
 163:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_SetRxInterruptMode(I2C_NO_INTR_SOURCES);
 164:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_SetTxInterruptMode(I2C_NO_INTR_SOURCES);
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 6


 165:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 166:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_state = I2C_I2C_FSM_IDLE;
 167:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 168:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else
 169:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 170:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Set I2C_FSM_EXIT_IDLE for BUS_ERR and ARB_LOST (that is really bus e
 171:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_state = I2C_I2C_FSM_EXIT_IDLE;
 172:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 173:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 174:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     else
 175:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 176:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Set I2C_FSM_EXIT_IDLE if any other state than address */
 177:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_state = I2C_I2C_FSM_EXIT_IDLE;
 178:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 179:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 180:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #else
 181:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 182:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* In case of LOST*/
 183:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_state = I2C_I2C_FSM_EXIT_IDLE;
 120              		.loc 1 183 0
 121 006a 0022     		mov	r2, #0
 122 006c 1A70     		strb	r2, [r3]
 123              	.L5:
 124              	.LVL10:
 184:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 185:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #endif
 186:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 187:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         }
 188:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         #endif
 189:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     }
 190:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     else /* (I2C_CHECK_I2C_FSM_SLAVE) */
 191:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     {
 192:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         #if(I2C_I2C_SLAVE)
 193:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         {
 194:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* INTR_SLAVE_I2C_BUS_ERROR or I2C_INTR_SLAVE_I2C_ARB_LOST:
 195:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * A Misplaced Start or Stop condition occurred on the bus: set a flag
 196:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * to notify an error condition.
 197:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 198:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_SLAVE_MASKED(I2C_INTR_SLAVE_I2C_BUS_ERROR |
 199:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                         I2C_INTR_SLAVE_I2C_ARB_LOST))
 200:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 201:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(I2C_CHECK_I2C_FSM_RD)
 202:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 203:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* TX direction: master reads from slave */
 204:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slStatus &= (uint8) ~I2C_I2C_SSTAT_RD_BUSY;
 205:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slStatus |= (uint8) (I2C_I2C_SSTAT_RD_ERR |
 206:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                           I2C_I2C_SSTAT_RD_CMPLT);
 207:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 208:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 else
 209:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 210:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* RX direction: master writes into slave */
 211:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slStatus &= (uint8) ~I2C_I2C_SSTAT_WR_BUSY;
 212:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slStatus |= (uint8) (I2C_I2C_SSTAT_WR_ERR |
 213:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                           I2C_I2C_SSTAT_WR_CMPLT);
 214:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 215:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 216:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_state = I2C_I2C_FSM_EXIT_IDLE;
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 7


 217:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 218:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         }
 219:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         #endif
 220:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     }
 221:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 222:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     /* States description:
 223:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     * Any Master operation starts from: the ADDR_RD/WR state as the master generates traffic on the
 224:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     * Any Slave operation starts from: the IDLE state as the slave always waits for actions from th
 225:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     */
 226:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 227:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     /* FSM Master */
 228:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     if(I2C_CHECK_I2C_FSM_MASTER)
 125              		.loc 1 228 0
 126 006e 1878     		ldrb	r0, [r3]
 127 0070 1022     		mov	r2, #16
 128 0072 8006     		lsl	r0, r0, #26
 129 0074 00D4     		bmi	.LCB120
 130 0076 F6E0     		b	.L11	@long jump
 131              	.LCB120:
 229:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     {
 230:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         #if(I2C_I2C_MASTER)
 231:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         {
 232:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* INTR_MASTER_I2C_STOP:
 233:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * A Stop condition was generated by the master: the end of the transaction.
 234:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * Set completion flags to notify the API.
 235:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 236:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_MASTER_MASKED(I2C_INTR_MASTER_I2C_STOP))
 132              		.loc 1 236 0
 133 0078 934C     		ldr	r4, .L72+16
 134 007a 2068     		ldr	r0, [r4]
 135 007c 1042     		tst	r0, r2
 136 007e 0CD0     		beq	.L12
 237:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 238:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearMasterInterruptSource(I2C_INTR_MASTER_I2C_STOP);
 137              		.loc 1 238 0
 138 0080 9349     		ldr	r1, .L72+24
 139              	.LVL11:
 239:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 240:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_mstrStatus |= (uint16) I2C_GET_I2C_MSTAT_CMPLT;
 140              		.loc 1 240 0
 141 0082 924C     		ldr	r4, .L72+20
 238:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 142              		.loc 1 238 0
 143 0084 0A60     		str	r2, [r1]
 144              		.loc 1 240 0
 145 0086 0121     		mov	r1, #1
 146 0088 1878     		ldrb	r0, [r3]
 147 008a 0140     		and	r1, r0
 148 008c 0220     		mov	r0, #2
 149 008e 411A     		sub	r1, r0, r1
 150 0090 2088     		ldrh	r0, [r4]
 151 0092 0143     		orr	r1, r0
 152 0094 89B2     		uxth	r1, r1
 153 0096 2180     		strh	r1, [r4]
 154 0098 DAE0     		b	.L70
 155              	.LVL12:
 156              	.L12:
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 8


 241:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_state       = I2C_I2C_FSM_IDLE;
 242:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 243:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             else
 244:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 245:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(I2C_CHECK_I2C_FSM_ADDR) /* Address stage */
 157              		.loc 1 245 0
 158 009a 1878     		ldrb	r0, [r3]
 159 009c 0007     		lsl	r0, r0, #28
 160 009e 1BD5     		bpl	.L15
 246:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 247:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* INTR_MASTER_I2C_NACK:
 248:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     * The master sent an address but it was NACKed by the slave. Complete transacti
 249:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     */
 250:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     if(I2C_CHECK_INTR_MASTER_MASKED(I2C_INTR_MASTER_I2C_NACK))
 161              		.loc 1 250 0
 162 00a0 0220     		mov	r0, #2
 163 00a2 2568     		ldr	r5, [r4]
 164 00a4 0542     		tst	r5, r0
 165 00a6 09D0     		beq	.L16
 251:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 252:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_ClearMasterInterruptSource(I2C_INTR_MASTER_I2C_NACK);
 166              		.loc 1 252 0
 167 00a8 894A     		ldr	r2, .L72+24
 253:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 254:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_mstrStatus |= (uint16) (I2C_I2C_MSTAT_ERR_XFER |
 168              		.loc 1 254 0
 169 00aa 8849     		ldr	r1, .L72+20
 170              	.LVL13:
 252:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 171              		.loc 1 252 0
 172 00ac 1060     		str	r0, [r2]
 173              		.loc 1 254 0
 174 00ae 8820     		mov	r0, #136
 175 00b0 0A88     		ldrh	r2, [r1]
 176 00b2 8000     		lsl	r0, r0, #2
 177 00b4 0243     		orr	r2, r0
 178 00b6 0A80     		strh	r2, [r1]
 179              	.LVL14:
 255:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                  I2C_I2C_MSTAT_ERR_ADDR_NAK);
 256:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 257:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
 180              		.loc 1 257 0
 181 00b8 0121     		mov	r1, #1
 182 00ba 0DE0     		b	.L15
 183              	.LVL15:
 184              	.L16:
 258:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 259:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* INTR_TX_UNDERFLOW. The master sent an address:
 260:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     *  - TX direction: the clock is stretched after the ACK phase, because the TX F
 261:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     *    EMPTY. The TX EMPTY cleans all the TX interrupt sources.
 262:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     *  - RX direction: the 1st byte is received, but there is no ACK permission,
 263:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     *    the clock is stretched after 1 byte is received.
 264:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     */
 265:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     else
 266:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 267:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         if(I2C_CHECK_I2C_FSM_RD) /* Reading */
 185              		.loc 1 267 0
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 9


 186 00bc 1878     		ldrb	r0, [r3]
 187 00be C007     		lsl	r0, r0, #31
 188 00c0 02D5     		bpl	.L17
 268:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 269:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_state = I2C_I2C_FSM_MSTR_RD_DATA;
 189              		.loc 1 269 0
 190 00c2 2522     		mov	r2, #37
 191 00c4 1A70     		strb	r2, [r3]
 192 00c6 07E0     		b	.L15
 193              	.L17:
 270:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 271:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else /* Writing */
 272:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 273:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_state = I2C_I2C_FSM_MSTR_WR_DATA;
 194              		.loc 1 273 0
 195 00c8 2420     		mov	r0, #36
 196 00ca 1870     		strb	r0, [r3]
 274:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             if(0u != I2C_mstrWrBufSize)
 197              		.loc 1 274 0
 198 00cc 8148     		ldr	r0, .L72+28
 199 00ce 0068     		ldr	r0, [r0]
 200 00d0 0028     		cmp	r0, #0
 201 00d2 01D0     		beq	.L15
 275:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 276:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 /* Enable INTR.TX_EMPTY if there is data to transmit */
 277:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_SetTxInterruptMode(I2C_INTR_TX_EMPTY);
 202              		.loc 1 277 0
 203 00d4 8048     		ldr	r0, .L72+32
 204 00d6 0260     		str	r2, [r0]
 205              	.LVL16:
 206              	.L15:
 278:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 279:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 280:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 281:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 282:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 283:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(I2C_CHECK_I2C_FSM_DATA) /* Data phase */
 207              		.loc 1 283 0
 208 00d8 0425     		mov	r5, #4
 209 00da 1A78     		ldrb	r2, [r3]
 210 00dc 2A42     		tst	r2, r5
 211 00de 00D1     		bne	.LCB209
 212 00e0 9BE0     		b	.L18	@long jump
 213              	.LCB209:
 284:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 285:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     if(I2C_CHECK_I2C_FSM_RD) /* Reading */
 214              		.loc 1 285 0
 215 00e2 0120     		mov	r0, #1
 216 00e4 1A78     		ldrb	r2, [r3]
 217 00e6 0242     		tst	r2, r0
 218 00e8 43D0     		beq	.L19
 286:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 287:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* INTR_RX_FULL:
 288:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * RX direction: the master received 8 bytes.
 289:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * Get data from RX FIFO and decide whether to ACK or  NACK the following by
 290:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 291:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         if(I2C_CHECK_INTR_RX_MASKED(I2C_INTR_RX_FULL))
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 10


 219              		.loc 1 291 0
 220 00ea 0826     		mov	r6, #8
 221 00ec 7B4A     		ldr	r2, .L72+36
 222 00ee 1468     		ldr	r4, [r2]
 223 00f0 3442     		tst	r4, r6
 224 00f2 23D0     		beq	.L20
 292:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 293:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Calculate difference */
 294:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             diffCount =  I2C_mstrRdBufSize -
 225              		.loc 1 294 0
 226 00f4 7A4A     		ldr	r2, .L72+40
 295:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                         (I2C_mstrRdBufIndex + I2C_GET_RX_FIFO_ENTRIES);
 227              		.loc 1 295 0
 228 00f6 7B4C     		ldr	r4, .L72+44
 294:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                         (I2C_mstrRdBufIndex + I2C_GET_RX_FIFO_ENTRIES);
 229              		.loc 1 294 0
 230 00f8 1568     		ldr	r5, [r2]
 231              		.loc 1 295 0
 232 00fa 2768     		ldr	r7, [r4]
 233 00fc 7A4A     		ldr	r2, .L72+48
 234 00fe EF1B     		sub	r7, r5, r7
 235 0100 0F25     		mov	r5, #15
 236 0102 1268     		ldr	r2, [r2]
 237 0104 2A40     		and	r2, r5
 294:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                         (I2C_mstrRdBufIndex + I2C_GET_RX_FIFO_ENTRIES);
 238              		.loc 1 294 0
 239 0106 BA1A     		sub	r2, r7, r2
 240              	.LVL17:
 296:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 297:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Proceed transaction or end it when RX FIFO becomes FULL again */
 298:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             if(diffCount > I2C_I2C_FIFO_SIZE)
 241              		.loc 1 298 0
 242 0108 B242     		cmp	r2, r6
 243 010a 07D8     		bhi	.L39
 299:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 300:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 diffCount = I2C_I2C_FIFO_SIZE;
 301:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 302:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             else
 303:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 304:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 if(0u == diffCount)
 244              		.loc 1 304 0
 245 010c 002A     		cmp	r2, #0
 246 010e 06D1     		bne	.L22
 305:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 {
 306:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     I2C_DISABLE_MASTER_AUTO_DATA_ACK;
 247              		.loc 1 306 0
 248 0110 7649     		ldr	r1, .L72+52
 249              	.LVL18:
 250 0112 774A     		ldr	r2, .L72+56
 251              	.LVL19:
 252 0114 0D68     		ldr	r5, [r1]
 253 0116 2A40     		and	r2, r5
 254 0118 0A60     		str	r2, [r1]
 255              	.LVL20:
 307:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 308:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     diffCount   = I2C_I2C_FIFO_SIZE;
 309:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 11


 256              		.loc 1 309 0
 257 011a 011C     		mov	r1, r0
 258              	.LVL21:
 259              	.L39:
 300:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 260              		.loc 1 300 0
 261 011c 321C     		mov	r2, r6
 262              	.LVL22:
 263              	.L22:
 310:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 }
 311:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 312:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 313:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             for(; (0u != diffCount); diffCount--)
 314:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 315:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_mstrRdBufPtr[I2C_mstrRdBufIndex] = (uint8)
 264              		.loc 1 315 0 discriminator 2
 265 011e 754D     		ldr	r5, .L72+60
 266 0120 2068     		ldr	r0, [r4]
 267 0122 2D68     		ldr	r5, [r5]
 313:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 268              		.loc 1 313 0 discriminator 2
 269 0124 013A     		sub	r2, r2, #1
 270              	.LVL23:
 271              		.loc 1 315 0 discriminator 2
 272 0126 2818     		add	r0, r5, r0
 316:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                                         I2C_RX_FIFO
 273              		.loc 1 316 0 discriminator 2
 274 0128 734D     		ldr	r5, .L72+64
 275 012a 2D68     		ldr	r5, [r5]
 315:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                                         I2C_RX_FIFO
 276              		.loc 1 315 0 discriminator 2
 277 012c EDB2     		uxtb	r5, r5
 278 012e 0570     		strb	r5, [r0]
 317:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_mstrRdBufIndex++;
 279              		.loc 1 317 0 discriminator 2
 280 0130 2068     		ldr	r0, [r4]
 281 0132 0130     		add	r0, r0, #1
 282 0134 2060     		str	r0, [r4]
 313:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 283              		.loc 1 313 0 discriminator 2
 284 0136 002A     		cmp	r2, #0
 285 0138 F1D1     		bne	.L22
 286 013a 17E0     		b	.L23
 287              	.LVL24:
 288              	.L20:
 318:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 319:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 320:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* INTR_RX_NOT_EMPTY:
 321:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * RX direction: the master received one data byte, ACK or NACK it.
 322:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * The last byte is stored and NACKed by the master. The NACK and Stop is
 323:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * generated by one command generate Stop.
 324:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 325:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else if(I2C_CHECK_INTR_RX_MASKED(I2C_INTR_RX_NOT_EMPTY))
 289              		.loc 1 325 0
 290 013c 1268     		ldr	r2, [r2]
 291 013e 2A42     		tst	r2, r5
 292 0140 14D0     		beq	.L23
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 12


 326:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 327:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Put data in component buffer */
 328:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_mstrRdBufPtr[I2C_mstrRdBufIndex] = (uint8) I2C_RX_FIFO_RD_REG;
 293              		.loc 1 328 0
 294 0142 684A     		ldr	r2, .L72+44
 295 0144 6B4E     		ldr	r6, .L72+60
 296 0146 1468     		ldr	r4, [r2]
 297 0148 3668     		ldr	r6, [r6]
 298 014a 3419     		add	r4, r6, r4
 299 014c 6A4E     		ldr	r6, .L72+64
 300 014e 3668     		ldr	r6, [r6]
 301 0150 F6B2     		uxtb	r6, r6
 302 0152 2670     		strb	r6, [r4]
 329:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_mstrRdBufIndex++;
 303              		.loc 1 329 0
 304 0154 1468     		ldr	r4, [r2]
 305 0156 0134     		add	r4, r4, #1
 306 0158 1460     		str	r4, [r2]
 330:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 331:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             if(I2C_mstrRdBufIndex < I2C_mstrRdBufSize)
 307              		.loc 1 331 0
 308 015a 1468     		ldr	r4, [r2]
 309 015c 604A     		ldr	r2, .L72+40
 310 015e 1268     		ldr	r2, [r2]
 311 0160 9442     		cmp	r4, r2
 312 0162 02D2     		bcs	.L40
 332:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 333:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_I2C_MASTER_GENERATE_ACK;
 313              		.loc 1 333 0
 314 0164 654A     		ldr	r2, .L72+68
 315 0166 1560     		str	r5, [r2]
 316 0168 00E0     		b	.L23
 317              	.L40:
 334:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 335:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             else
 336:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 337:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
 318              		.loc 1 337 0
 319 016a 011C     		mov	r1, r0
 320              	.LVL25:
 321              	.L23:
 338:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 339:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 340:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else
 341:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 342:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Do nothing */
 343:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 344:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 345:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_ClearRxInterruptSource(I2C_INTR_RX_ALL);
 322              		.loc 1 345 0
 323 016c 6448     		ldr	r0, .L72+72
 324 016e 654A     		ldr	r2, .L72+76
 325 0170 49E0     		b	.L68
 326              	.L19:
 346:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 347:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     else /* Writing */
 348:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 13


 349:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* INTR_MASTER_I2C_NACK :
 350:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * The master writes data to the slave and NACK was received: not all the by
 351:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * written to the slave from the TX FIFO. Revert the index if there is data 
 352:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * the TX FIFO and pass control to a complete transfer.
 353:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 354:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         if(I2C_CHECK_INTR_MASTER_MASKED(I2C_INTR_MASTER_I2C_NACK))
 327              		.loc 1 354 0
 328 0172 0222     		mov	r2, #2
 329 0174 2468     		ldr	r4, [r4]
 330 0176 1442     		tst	r4, r2
 331 0178 20D0     		beq	.L24
 355:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 356:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_ClearMasterInterruptSource(I2C_INTR_MASTER_I2C_NACK);
 332              		.loc 1 356 0
 333 017a 5549     		ldr	r1, .L72+24
 334              	.LVL26:
 357:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 358:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Rollback write buffer index: NACKed byte remains in shifter */
 359:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_mstrWrBufIndexTmp -= (I2C_GET_TX_FIFO_ENTRIES +
 335              		.loc 1 359 0
 336 017c 624C     		ldr	r4, .L72+80
 356:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 337              		.loc 1 356 0
 338 017e 0A60     		str	r2, [r1]
 339              		.loc 1 359 0
 340 0180 6249     		ldr	r1, .L72+84
 341 0182 0D32     		add	r2, r2, #13
 342 0184 0E68     		ldr	r6, [r1]
 360:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                    I2C_GET_TX_FIFO_SR_VALID);
 343              		.loc 1 360 0
 344 0186 0D68     		ldr	r5, [r1]
 359:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                    I2C_GET_TX_FIFO_SR_VALID);
 345              		.loc 1 359 0
 346 0188 2168     		ldr	r1, [r4]
 347 018a 3240     		and	r2, r6
 348 018c 8A1A     		sub	r2, r1, r2
 349 018e E90B     		lsr	r1, r5, #15
 350 0190 0840     		and	r0, r1
 351 0192 101A     		sub	r0, r2, r0
 352 0194 2060     		str	r0, [r4]
 361:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 362:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Update number of transferred bytes */
 363:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_mstrWrBufIndex = I2C_mstrWrBufIndexTmp;
 364:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 365:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_mstrStatus |= (uint16) (I2C_I2C_MSTAT_ERR_XFER |
 353              		.loc 1 365 0
 354 0196 8420     		mov	r0, #132
 363:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 355              		.loc 1 363 0
 356 0198 2168     		ldr	r1, [r4]
 357 019a 5D4A     		ldr	r2, .L72+88
 358              		.loc 1 365 0
 359 019c 8000     		lsl	r0, r0, #2
 363:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 360              		.loc 1 363 0
 361 019e 1160     		str	r1, [r2]
 362              		.loc 1 365 0
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 14


 363 01a0 4A49     		ldr	r1, .L72+20
 364 01a2 0A88     		ldrh	r2, [r1]
 365 01a4 0243     		orr	r2, r0
 366:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                      I2C_I2C_MSTAT_ERR_SHORT_XFER);
 367:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 368:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_CLEAR_TX_FIFO;
 366              		.loc 1 368 0
 367 01a6 8020     		mov	r0, #128
 365:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                      I2C_I2C_MSTAT_ERR_SHORT_XFER);
 368              		.loc 1 365 0
 369 01a8 0A80     		strh	r2, [r1]
 370              		.loc 1 368 0
 371 01aa 5A4A     		ldr	r2, .L72+92
 372 01ac 4002     		lsl	r0, r0, #9
 373 01ae 1168     		ldr	r1, [r2]
 374 01b0 0143     		orr	r1, r0
 375 01b2 1160     		str	r1, [r2]
 376 01b4 1068     		ldr	r0, [r2]
 377 01b6 5849     		ldr	r1, .L72+96
 378 01b8 0140     		and	r1, r0
 379 01ba 2CE0     		b	.L69
 380              	.LVL27:
 381              	.L24:
 369:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 370:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
 371:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 372:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* INTR_TX_EMPTY :
 373:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * TX direction: the TX FIFO is EMPTY, the data from the buffer needs to be 
 374:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * When there is no data in the component buffer, the underflow interrupt is
 375:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * enabled to catch when all the data has been transferred.
 376:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 377:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else if(I2C_CHECK_INTR_TX_MASKED(I2C_INTR_TX_EMPTY))
 382              		.loc 1 377 0
 383 01bc 574A     		ldr	r2, .L72+100
 384 01be 1068     		ldr	r0, [r2]
 385 01c0 C006     		lsl	r0, r0, #27
 386 01c2 22D5     		bpl	.L26
 378:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 379:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             while(I2C_I2C_FIFO_SIZE != I2C_GET_TX_FIFO_ENTRIES)
 380:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 381:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 /* The temporary mstrWrBufIndexTmp is used because slave could NACK
 382:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 * roll-back required in this case. The mstrWrBufIndex is updated at
 383:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 */
 384:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 if(I2C_mstrWrBufIndexTmp < I2C_mstrWrBufSize)
 385:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 {
 386:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 #if(!I2C_CY_SCBIP_V0)
 387:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                    /* Clear INTR_TX.UNDERFLOW before putting the last byte into TX 
 388:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     * a proper trigger at the end of transaction when INTR_TX.UNDER
 389:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     * event. Ticket ID# 156735.
 390:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     */
 391:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     if(I2C_mstrWrBufIndexTmp == (I2C_mstrWrBufSize - 1u))
 392:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     {
 393:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                         I2C_ClearTxInterruptSource(I2C_INTR_TX_UNDERFLOW);
 394:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                         I2C_SetTxInterruptMode(I2C_INTR_TX_UNDERFLOW);
 395:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     }
 396:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                  #endif /* (!I2C_CY_SCBIP_V0) */
 397:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 15


 398:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     /* Put data into TX FIFO */
 399:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     I2C_TX_FIFO_WR_REG = (uint32) I2C_mstrWrBufPtr[I2C_mstrWrBufInd
 387              		.loc 1 399 0
 388 01c4 564A     		ldr	r2, .L72+104
 389 01c6 1468     		ldr	r4, [r2]
 390              	.L27:
 379:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 391              		.loc 1 379 0
 392 01c8 504A     		ldr	r2, .L72+84
 393 01ca 424D     		ldr	r5, .L72+28
 394 01cc 1068     		ldr	r0, [r2]
 395 01ce 0F22     		mov	r2, #15
 396 01d0 1040     		and	r0, r2
 397 01d2 4D4A     		ldr	r2, .L72+80
 398 01d4 0828     		cmp	r0, #8
 399 01d6 0DD0     		beq	.L28
 384:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 {
 400              		.loc 1 384 0
 401 01d8 1668     		ldr	r6, [r2]
 402 01da 2868     		ldr	r0, [r5]
 403 01dc 8642     		cmp	r6, r0
 404 01de 09D2     		bcs	.L28
 405              		.loc 1 399 0
 406 01e0 1068     		ldr	r0, [r2]
 407 01e2 504D     		ldr	r5, .L72+108
 408 01e4 2018     		add	r0, r4, r0
 409 01e6 0078     		ldrb	r0, [r0]
 410 01e8 C0B2     		uxtb	r0, r0
 411 01ea 2860     		str	r0, [r5]
 400:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     I2C_mstrWrBufIndexTmp++;
 412              		.loc 1 400 0
 413 01ec 1068     		ldr	r0, [r2]
 414 01ee 0130     		add	r0, r0, #1
 415 01f0 1060     		str	r0, [r2]
 416 01f2 E9E7     		b	.L27
 417              	.L28:
 401:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 }
 402:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 else
 403:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 {
 404:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     break; /* No more data to put */
 405:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 }
 406:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 407:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 408:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #if(I2C_CY_SCBIP_V0)
 409:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             if(I2C_mstrWrBufIndexTmp == I2C_mstrWrBufSize)
 418              		.loc 1 409 0
 419 01f4 1068     		ldr	r0, [r2]
 420 01f6 2A68     		ldr	r2, [r5]
 421 01f8 9042     		cmp	r0, r2
 422 01fa 02D1     		bne	.L30
 410:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 411:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_SetTxInterruptMode(I2C_INTR_TX_UNDERFLOW);
 423              		.loc 1 411 0
 424 01fc 4020     		mov	r0, #64
 425 01fe 364A     		ldr	r2, .L72+32
 426 0200 1060     		str	r0, [r2]
 427              	.L30:
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 16


 412:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 413:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 414:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_ClearTxInterruptSource(I2C_INTR_TX_ALL);
 428              		.loc 1 414 0
 429 0202 4948     		ldr	r0, .L72+112
 430 0204 494A     		ldr	r2, .L72+116
 431              	.L68:
 432 0206 1060     		str	r0, [r2]
 433 0208 07E0     		b	.L18
 434              	.L26:
 415:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #else
 416:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_ClearTxInterruptSource(I2C_INTR_TX_EMPTY);
 417:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #endif /* (I2C_CY_SCBIP_V0) */
 418:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 419:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* INTR_TX_UNDERFLOW:
 420:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * TX direction: all data from the TX FIFO was transferred to the slave.
 421:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * The transaction needs to be completed.
 422:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 423:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else if(I2C_CHECK_INTR_TX_MASKED(I2C_INTR_TX_UNDERFLOW))
 435              		.loc 1 423 0
 436 020a 1268     		ldr	r2, [r2]
 437 020c 5206     		lsl	r2, r2, #25
 438 020e 04D5     		bpl	.L18
 424:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 425:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Update number of transferred bytes */
 426:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_mstrWrBufIndex = I2C_mstrWrBufIndexTmp;
 439              		.loc 1 426 0
 440 0210 3D4A     		ldr	r2, .L72+80
 441 0212 1168     		ldr	r1, [r2]
 442              	.LVL28:
 443 0214 3E4A     		ldr	r2, .L72+88
 444              	.L69:
 445 0216 1160     		str	r1, [r2]
 446              	.LVL29:
 447 0218 01E0     		b	.L31
 448              	.LVL30:
 449              	.L18:
 427:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 428:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
 429:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 430:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else
 431:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 432:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Do nothing */
 433:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 434:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 435:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 436:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 437:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(0u != endTransfer) /* Complete transfer */
 450              		.loc 1 437 0
 451 021a 0029     		cmp	r1, #0
 452 021c 4AD0     		beq	.L1
 453              	.LVL31:
 454              	.L31:
 438:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 439:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Clean-up master after reading: only in case of NACK */
 440:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_DISABLE_MASTER_AUTO_DATA_ACK;
 455              		.loc 1 440 0
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 17


 456 021e 3349     		ldr	r1, .L72+52
 457 0220 334A     		ldr	r2, .L72+56
 458 0222 0868     		ldr	r0, [r1]
 459 0224 0240     		and	r2, r0
 460 0226 0A60     		str	r2, [r1]
 441:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 442:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Disable data processing interrupts: they have to be cleared before */
 443:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_SetRxInterruptMode(I2C_NO_INTR_SOURCES);
 461              		.loc 1 443 0
 462 0228 0022     		mov	r2, #0
 463 022a 4149     		ldr	r1, .L72+120
 464 022c 0A60     		str	r2, [r1]
 444:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_SetTxInterruptMode(I2C_NO_INTR_SOURCES);
 465              		.loc 1 444 0
 466 022e 2A49     		ldr	r1, .L72+32
 467 0230 0A60     		str	r2, [r1]
 445:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 446:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     if(I2C_CHECK_I2C_MODE_NO_STOP(I2C_mstrControl))
 468              		.loc 1 446 0
 469 0232 404A     		ldr	r2, .L72+124
 470 0234 1278     		ldrb	r2, [r2]
 471 0236 9207     		lsl	r2, r2, #30
 472 0238 0CD5     		bpl	.L32
 447:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 448:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* On-going transaction is suspended: the ReStart is generated by the API r
 449:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_mstrStatus |= (uint16) (I2C_I2C_MSTAT_XFER_HALT |
 473              		.loc 1 449 0
 474 023a 0122     		mov	r2, #1
 450:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                  I2C_GET_I2C_MSTAT_CMPLT);
 475              		.loc 1 450 0
 476 023c 1978     		ldrb	r1, [r3]
 449:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                  I2C_GET_I2C_MSTAT_CMPLT);
 477              		.loc 1 449 0
 478 023e 2348     		ldr	r0, .L72+20
 479 0240 0A40     		and	r2, r1
 480 0242 0A21     		mov	r1, #10
 481 0244 8A1A     		sub	r2, r1, r2
 482 0246 0188     		ldrh	r1, [r0]
 483 0248 0A43     		orr	r2, r1
 484 024a 92B2     		uxth	r2, r2
 485 024c 0280     		strh	r2, [r0]
 451:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 452:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_state = I2C_I2C_FSM_MSTR_HALT;
 486              		.loc 1 452 0
 487 024e 6022     		mov	r2, #96
 488              	.L70:
 489 0250 1A70     		strb	r2, [r3]
 490 0252 2FE0     		b	.L1
 491              	.L32:
 453:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 454:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     else
 455:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 456:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Complete transaction: exclude the data processing state and generate Sto
 457:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * The completion status will be set after Stop generation.
 458:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * A special case is read: because NACK and Stop are generated by the comman
 459:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * Lost arbitration can occur during NACK generation when
 460:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * the other master is still reading from the slave.
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 18


 461:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 462:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_I2C_MASTER_GENERATE_STOP;
 492              		.loc 1 462 0
 493 0254 384B     		ldr	r3, .L72+128
 494 0256 1A68     		ldr	r2, [r3]
 495 0258 1823     		mov	r3, #24
 496 025a 9206     		lsl	r2, r2, #26
 497 025c 00D4     		bmi	.L34
 498 025e 083B     		sub	r3, r3, #8
 499              	.L34:
 500              		.loc 1 462 0 is_stmt 0 discriminator 4
 501 0260 264A     		ldr	r2, .L72+68
 502 0262 1360     		str	r3, [r2]
 503 0264 26E0     		b	.L1
 504              	.LVL32:
 505              	.L11:
 463:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 464:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 465:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 466:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 467:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         } /* (I2C_I2C_MASTER) */
 468:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         #endif
 469:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 470:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     } /* (I2C_CHECK_I2C_FSM_MASTER) */
 471:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 472:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 473:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     /* FSM Slave */
 474:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     else if(I2C_CHECK_I2C_FSM_SLAVE)
 506              		.loc 1 474 0 is_stmt 1
 507 0266 1978     		ldrb	r1, [r3]
 508              	.LVL33:
 509 0268 1140     		and	r1, r2
 510 026a 23D1     		bne	.L1
 475:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     {
 476:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         #if(I2C_I2C_SLAVE)
 477:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         {
 478:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* INTR_SLAVE_NACK:
 479:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The master completes reading the slave: the appropriate flags have to be set.
 480:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The TX FIFO is cleared after an overflow condition is set.
 481:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 482:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_SLAVE_MASKED(I2C_INTR_SLAVE_I2C_NACK))
 483:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 484:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearSlaveInterruptSource(I2C_INTR_SLAVE_I2C_NACK);
 485:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 486:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* All entries that remain in TX FIFO max value is 9: 8 (FIFO) + 1 (SHIFTER) */
 487:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 diffCount = (I2C_GET_TX_FIFO_ENTRIES + I2C_GET_TX_FIFO_SR_VALID);
 488:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 489:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(I2C_slOverFlowCount > diffCount) /* Overflow */
 490:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 491:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slStatus |= (uint8) I2C_I2C_SSTAT_RD_OVFL;
 492:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 493:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 else /* No Overflow */
 494:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 495:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Roll-back temporary index */
 496:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slRdBufIndexTmp -= (diffCount - I2C_slOverFlowCount);
 497:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 498:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 19


 499:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Update slave of transferred bytes */
 500:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_slRdBufIndex = I2C_slRdBufIndexTmp;
 501:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 502:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Clean-up TX FIFO */
 503:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_SetTxInterruptMode(I2C_NO_INTR_SOURCES);
 504:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_slOverFlowCount = 0u;
 505:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_CLEAR_TX_FIFO;
 506:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 507:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Complete master reading */
 508:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_slStatus &= (uint8) ~I2C_I2C_SSTAT_RD_BUSY;
 509:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_slStatus |= (uint8)  I2C_I2C_SSTAT_RD_CMPLT;
 510:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_state     =  I2C_I2C_FSM_IDLE;
 511:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 512:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 513:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 514:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* INTR_SLAVE_I2C_WRITE_STOP:
 515:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The master completes writing to the slave: the appropriate flags have to be set.
 516:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The RX FIFO contains 1-8 bytes from the previous transaction which needs to be read.
 517:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * There is a possibility that RX FIFO contains an address, it needs to leave it there.
 518:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 519:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_SLAVE_MASKED(I2C_INTR_SLAVE_I2C_WRITE_STOP))
 520:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 521:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearSlaveInterruptSource(I2C_INTR_SLAVE_I2C_WRITE_STOP);
 522:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 523:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Read bytes from RX FIFO when auto data ACK receive logic is enabled. Otherwise a
 524:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 * were already read from the RX FIFO except for address byte which has to stay here
 525:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 * I2C_ADDR_MATCH.
 526:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 */
 527:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if (0u != (I2C_I2C_CTRL_REG & I2C_I2C_CTRL_S_READY_DATA_ACK))
 528:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 529:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     while(0u != I2C_GET_RX_FIFO_ENTRIES)
 530:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 531:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #if(I2C_CHECK_I2C_ACCEPT_ADDRESS)
 532:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 533:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             if((1u == I2C_GET_RX_FIFO_ENTRIES) &&
 534:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                (I2C_CHECK_INTR_SLAVE_MASKED(I2C_INTR_SLAVE_I2C_ADDR_MATCH)))
 535:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 536:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 break; /* Leave address in RX FIFO */
 537:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 538:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 539:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #endif
 540:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 541:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Put data in component buffer */
 542:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_slWrBufPtr[I2C_slWrBufIndex] = (uint8) I2C_RX_FIFO_RD_REG;
 543:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_slWrBufIndex++;
 544:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 545:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 546:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_DISABLE_SLAVE_AUTO_DATA;
 547:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 548:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 549:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(I2C_CHECK_INTR_RX(I2C_INTR_RX_OVERFLOW))
 550:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 551:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slStatus |= (uint8) I2C_I2C_SSTAT_WR_OVFL;
 552:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 553:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 554:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Clears RX interrupt sources triggered on data receiving */
 555:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_SetRxInterruptMode(I2C_NO_INTR_SOURCES);
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 20


 556:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearRxInterruptSource(I2C_INTR_RX_ALL);
 557:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 558:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Complete master writing */
 559:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_slStatus &= (uint8) ~I2C_I2C_SSTAT_WR_BUSY;
 560:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_slStatus |= (uint8)  I2C_I2C_SSTAT_WR_CMPLT;
 561:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_state     =  I2C_I2C_FSM_IDLE;
 562:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 563:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 564:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 565:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* INTR_SLAVE_I2C_ADDR_MATCH or INTR_SLAVE_I2C_GENERAL:
 566:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The address match or general call address event starts the slave operation:
 567:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * after leaving the TX or RX direction has to be chosen.
 568:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The wakeup interrupt must be cleared only after an address match is set.
 569:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 570:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         #if (I2C_I2C_CUSTOM_ADDRESS_HANDLER_CONST)
 571:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             if (I2C_CHECK_INTR_SLAVE_MASKED(I2C_INTR_SLAVE_I2C_ADDR_MATCH |
 572:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                          I2C_INTR_SLAVE_I2C_GENERAL))
 573:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         #else
 574:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             if (I2C_CHECK_INTR_SLAVE_MASKED(I2C_INTR_SLAVE_I2C_ADDR_MATCH))
 575:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         #endif /* (I2C_I2C_CUSTOM_ADDRESS_HANDLER_CONST) */
 576:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 577:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Clear externally clocked address match interrupt source when internally clocked 
 578:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearI2CExtClkInterruptSource(I2C_INTR_I2C_EC_WAKE_UP);
 579:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 580:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #if (I2C_I2C_CUSTOM_ADDRESS_HANDLER)
 581:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 582:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     if (NULL != I2C_customAddressHandler)
 583:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 584:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Call custom address handler */
 585:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         response = I2C_customAddressHandler();
 586:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 587:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     else
 588:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 589:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Read address from the RX FIFO. If there is no address underflow triggers
 590:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * componnet does not use that source. */
 591:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         (void) I2C_RX_FIFO_RD_REG;
 592:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         response = I2C_I2C_ACK_ADDR;
 593:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 594:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 595:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Clears RX sources after address was received in the RX FIFO */
 596:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_ClearRxInterruptSource(I2C_INTR_RX_ALL);
 597:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 598:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #endif
 599:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 600:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             #if (I2C_I2C_CUSTOM_ADDRESS_HANDLER_CONST)
 601:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if (response == I2C_I2C_NAK_ADDR)
 602:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 603:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #if (!I2C_CY_SCBIP_V0)
 604:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Disable write stop interrupt source as it triggers after address was NACKed.
 605:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_DISABLE_INTR_SLAVE(I2C_INTR_SLAVE_I2C_WRITE_STOP);
 606:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #endif /* (!I2C_CY_SCBIP_V0) */
 607:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 608:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Clear address match and stop history */
 609:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_ClearSlaveInterruptSource(I2C_INTR_SLAVE_ALL);
 610:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 611:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* ACK the address byte */
 612:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_I2C_SLAVE_GENERATE_NACK;
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 21


 613:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 614:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 else
 615:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             #endif /* (I2C_I2C_CUSTOM_ADDRESS_HANDLER_CONST) */
 616:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 617:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     if(I2C_CHECK_I2C_STATUS(I2C_I2C_STATUS_S_READ))
 618:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* TX direction: master reads from slave */
 619:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 620:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_SetTxInterruptMode(I2C_INTR_TX_EMPTY);
 621:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 622:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Set temporary index to address buffer clear from API */
 623:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_slRdBufIndexTmp = I2C_slRdBufIndex;
 624:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 625:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Start master reading */
 626:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_slStatus |= (uint8) I2C_I2C_SSTAT_RD_BUSY;
 627:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_state     = I2C_I2C_FSM_SL_RD;
 628:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 629:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     else
 630:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* RX direction: master writes into slave */
 631:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 632:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Calculate available buffer size */
 633:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         diffCount = (I2C_slWrBufSize - I2C_slWrBufIndex);
 634:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 635:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     #if (I2C_CY_SCBIP_V0)
 636:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         if(diffCount < I2C_I2C_FIFO_SIZE)
 637:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Receive data: byte-by-byte */
 638:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 639:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_SetRxInterruptMode(I2C_INTR_RX_NOT_EMPTY);
 640:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 641:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else
 642:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Receive data: into RX FIFO */
 643:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 644:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             if(diffCount == I2C_I2C_FIFO_SIZE)
 645:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 646:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 /* NACK when RX FIFO become FULL */
 647:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_ENABLE_SLAVE_AUTO_DATA;
 648:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 649:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             else
 650:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 651:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 /* Stretch clock when RX FIFO becomes FULL */
 652:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_ENABLE_SLAVE_AUTO_DATA_ACK;
 653:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_SetRxInterruptMode(I2C_INTR_RX_FULL);
 654:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 655:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 656:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 657:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     #else
 658:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #if(I2C_CHECK_I2C_ACCEPT_ADDRESS)
 659:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 660:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Enable RX.NOT_EMPTY interrupt source to receive byte by byte.
 661:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             * The byte by byte receive is always chosen for the case when an addres
 662:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             * in RX FIFO. Ticket ID#175559.
 663:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             */
 664:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_SetRxInterruptMode(I2C_INTR_RX_NOT_EMPTY);
 665:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 666:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #else
 667:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 668:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             if(diffCount < I2C_I2C_FIFO_SIZE)
 669:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Receive data: byte-by-byte */
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 22


 670:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 671:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_SetRxInterruptMode(I2C_INTR_RX_NOT_EMPTY);
 672:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 673:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             else
 674:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Receive data: into RX FIFO */
 675:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 676:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 if(diffCount == I2C_I2C_FIFO_SIZE)
 677:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 {
 678:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     /* NACK when RX FIFO become FULL */
 679:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     I2C_ENABLE_SLAVE_AUTO_DATA;
 680:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 }
 681:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 else
 682:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 {
 683:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     /* Stretch clock when RX FIFO becomes FULL */
 684:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     I2C_ENABLE_SLAVE_AUTO_DATA_ACK;
 685:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     I2C_SetRxInterruptMode(I2C_INTR_RX_FULL);
 686:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 }
 687:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 688:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 689:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #endif
 690:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     #endif /* (I2C_CY_SCBIP_V0) */
 691:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 692:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Start master reading */
 693:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_slStatus |= (uint8) I2C_I2C_SSTAT_WR_BUSY;
 694:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_state     = I2C_I2C_FSM_SL_WR;
 695:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 696:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 697:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Clear address match and stop history */
 698:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_ClearSlaveInterruptSource(I2C_INTR_SLAVE_ALL);
 699:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 700:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #if (!I2C_CY_SCBIP_V0)
 701:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Enable write stop interrupt source as it triggers after address was NACKed. 
 702:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_ENABLE_INTR_SLAVE(I2C_INTR_SLAVE_I2C_WRITE_STOP);
 703:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #endif /* (!I2C_CY_SCBIP_V0) */
 704:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 705:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* ACK the address byte */
 706:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_I2C_SLAVE_GENERATE_ACK;
 707:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 708:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 709:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 710:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* I2C_INTR_RX_FULL:
 711:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * Get data from the RX FIFO and decide whether to ACK or NACK the following bytes
 712:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 713:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_RX_MASKED(I2C_INTR_RX_FULL))
 714:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 715:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Calculate available buffer size to take into account that RX FIFO is FULL */
 716:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 diffCount =  I2C_slWrBufSize -
 717:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             (I2C_slWrBufIndex + I2C_I2C_FIFO_SIZE);
 718:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 719:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(diffCount > I2C_I2C_FIFO_SIZE) /* Proceed transaction */
 720:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 721:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     diffCount   = I2C_I2C_FIFO_SIZE;
 722:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     endTransfer = 0u;  /* Continue active transfer */
 723:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 724:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 else /* End when FIFO becomes FULL again */
 725:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 726:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 23


 727:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 728:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 729:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 for(; (0u != diffCount); diffCount--)
 730:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 731:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Put data in component buffer */
 732:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slWrBufPtr[I2C_slWrBufIndex] = (uint8) I2C_RX_FIFO_RD_REG;
 733:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slWrBufIndex++;
 734:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 735:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 736:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(0u != endTransfer) /* End transfer sending NACK */
 737:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 738:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_ENABLE_SLAVE_AUTO_DATA_NACK;
 739:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 740:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* INTR_RX_FULL triggers earlier than INTR_SLAVE_I2C_STOP:
 741:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     * disable all RX interrupt sources.
 742:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     */
 743:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_SetRxInterruptMode(I2C_NO_INTR_SOURCES);
 744:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 745:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 746:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearRxInterruptSource(I2C_INTR_RX_FULL);
 747:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 748:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* I2C_INTR_RX_NOT_EMPTY:
 749:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The buffer size is less than 8: it requires processing in byte-by-byte mode.
 750:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 751:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             else if(I2C_CHECK_INTR_RX_MASKED(I2C_INTR_RX_NOT_EMPTY))
 752:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 753:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 diffCount = I2C_RX_FIFO_RD_REG;
 754:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 755:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(I2C_slWrBufIndex < I2C_slWrBufSize)
 756:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 757:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_I2C_SLAVE_GENERATE_ACK;
 758:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 759:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Put data into component buffer */
 760:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slWrBufPtr[I2C_slWrBufIndex] = (uint8) diffCount;
 761:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slWrBufIndex++;
 762:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 763:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 else /* Overflow: there is no space in write buffer */
 764:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 765:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_I2C_SLAVE_GENERATE_NACK;
 766:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 767:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slStatus |= (uint8) I2C_I2C_SSTAT_WR_OVFL;
 768:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 769:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 770:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearRxInterruptSource(I2C_INTR_RX_NOT_EMPTY);
 771:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 772:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             else
 773:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 774:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Does nothing */
 775:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 776:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 777:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 778:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* I2C_INTR_TX_EMPTY:
 779:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The master reads the slave: provide data to read or 0xFF in the case of the end of th
 780:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The overflow condition must be captured, but not set until the end of transaction.
 781:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * There is a possibility of a false overflow due to TX FIFO utilization.
 782:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 783:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_TX_MASKED(I2C_INTR_TX_EMPTY))
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 24


 784:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 785:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 while(I2C_I2C_FIFO_SIZE != I2C_GET_TX_FIFO_ENTRIES)
 786:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 787:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Temporary slRdBufIndexTmp is used because the master can NACK the byte and
 788:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     * index roll-back is required in this case. The slRdBufIndex is updated at the 
 789:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     * of the read transfer.
 790:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     */
 791:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     if(I2C_slRdBufIndexTmp < I2C_slRdBufSize)
 792:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Data from buffer */
 793:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 794:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_TX_FIFO_WR_REG = (uint32) I2C_slRdBufPtr[I2C_slRdBufIndexTmp];
 795:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_slRdBufIndexTmp++;
 796:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 797:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     else
 798:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Probably Overflow */
 799:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 800:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_TX_FIFO_WR_REG = I2C_I2C_SLAVE_OVFL_RETURN;
 801:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 802:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         if(0u == (I2C_INTR_TX_OVERFLOW & I2C_slOverFlowCount))
 803:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 804:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Get counter in range of byte: value 10 is overflow */
 805:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_slOverFlowCount++;
 806:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 807:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 808:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 809:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 810:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearTxInterruptSource(I2C_INTR_TX_EMPTY);
 811:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 812:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 813:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         }  /* (I2C_I2C_SLAVE) */
 814:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         #endif
 815:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     }
 816:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 817:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 818:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     /* FSM EXIT:
 819:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     * Slave:  INTR_SLAVE_I2C_BUS_ERROR, INTR_SLAVE_I2C_ARB_LOST
 820:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     * Master: INTR_MASTER_I2C_BUS_ERROR, INTR_MASTER_I2C_ARB_LOST.
 821:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     */
 822:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     else
 823:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     {
 824:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_CTRL_REG &= (uint32) ~I2C_CTRL_ENABLED; /* Disable scb IP */
 511              		.loc 1 824 0
 512 026c 334C     		ldr	r4, .L72+132
 513 026e 2068     		ldr	r0, [r4]
 514 0270 4000     		lsl	r0, r0, #1
 515 0272 4008     		lsr	r0, r0, #1
 516 0274 2060     		str	r0, [r4]
 825:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 826:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_state = I2C_I2C_FSM_IDLE;
 517              		.loc 1 826 0
 518 0276 1A70     		strb	r2, [r3]
 827:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 828:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_DISABLE_SLAVE_AUTO_DATA;
 519              		.loc 1 828 0
 520 0278 1C4B     		ldr	r3, .L72+52
 521 027a 314A     		ldr	r2, .L72+136
 522 027c 1868     		ldr	r0, [r3]
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 25


 523 027e 0240     		and	r2, r0
 524 0280 1A60     		str	r2, [r3]
 829:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_DISABLE_MASTER_AUTO_DATA;
 525              		.loc 1 829 0
 526 0282 1868     		ldr	r0, [r3]
 527 0284 2F4A     		ldr	r2, .L72+140
 528 0286 0240     		and	r2, r0
 529 0288 1A60     		str	r2, [r3]
 830:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 831:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     #if(I2C_CY_SCBIP_V0)
 832:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_SetRxInterruptMode(I2C_NO_INTR_SOURCES);
 530              		.loc 1 832 0
 531 028a 294B     		ldr	r3, .L72+120
 833:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_SetTxInterruptMode(I2C_NO_INTR_SOURCES);
 834:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 835:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         /* Clear interrupt sources as they are not automatically cleared after SCB is disabled */
 836:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_ClearTxInterruptSource(I2C_INTR_RX_ALL);
 532              		.loc 1 836 0
 533 028c 1C4A     		ldr	r2, .L72+72
 832:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_SetTxInterruptMode(I2C_NO_INTR_SOURCES);
 534              		.loc 1 832 0
 535 028e 1960     		str	r1, [r3]
 833:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_SetTxInterruptMode(I2C_NO_INTR_SOURCES);
 536              		.loc 1 833 0
 537 0290 114B     		ldr	r3, .L72+32
 538 0292 1960     		str	r1, [r3]
 539              		.loc 1 836 0
 540 0294 254B     		ldr	r3, .L72+116
 541 0296 1A60     		str	r2, [r3]
 837:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_ClearRxInterruptSource(I2C_INTR_TX_ALL);
 542              		.loc 1 837 0
 543 0298 234A     		ldr	r2, .L72+112
 544 029a 1A4B     		ldr	r3, .L72+76
 545 029c 1A60     		str	r2, [r3]
 838:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_ClearSlaveInterruptSource(I2C_INTR_SLAVE_ALL);
 546              		.loc 1 838 0
 547 029e 2A4A     		ldr	r2, .L72+144
 548 02a0 2A4B     		ldr	r3, .L72+148
 549 02a2 1A60     		str	r2, [r3]
 839:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_ClearMasterInterruptSource(I2C_INTR_MASTER_ALL);
 550              		.loc 1 839 0
 551 02a4 2A4A     		ldr	r2, .L72+152
 552 02a6 0A4B     		ldr	r3, .L72+24
 553 02a8 1A60     		str	r2, [r3]
 840:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     #endif /* (I2C_CY_SCBIP_V0) */
 841:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 842:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_CTRL_REG |= (uint32) I2C_CTRL_ENABLED;  /* Enable scb IP */
 554              		.loc 1 842 0
 555 02aa 8022     		mov	r2, #128
 556 02ac 2368     		ldr	r3, [r4]
 557 02ae 1206     		lsl	r2, r2, #24
 558 02b0 1343     		orr	r3, r2
 559 02b2 2360     		str	r3, [r4]
 560              	.L1:
 843:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     }
 844:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 845:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** #ifdef I2C_I2C_ISR_EXIT_CALLBACK
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 26


 846:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     I2C_I2C_ISR_ExitCallback();
 847:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** #endif /* I2C_I2C_ISR_EXIT_CALLBACK */
 848:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     
 849:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** }
 561              		.loc 1 849 0
 562              		@ sp needed
 563 02b4 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 564              	.L73:
 565 02b6 C046     		.align	2
 566              	.L72:
 567 02b8 00000000 		.word	I2C_customIntrHandler
 568 02bc 8C0E0740 		.word	1074204300
 569 02c0 880E0740 		.word	1074204296
 570 02c4 00000000 		.word	I2C_state
 571 02c8 0C0F0740 		.word	1074204428
 572 02cc 00000000 		.word	I2C_mstrStatus
 573 02d0 000F0740 		.word	1074204416
 574 02d4 00000000 		.word	I2C_mstrWrBufSize
 575 02d8 880F0740 		.word	1074204552
 576 02dc CC0F0740 		.word	1074204620
 577 02e0 00000000 		.word	I2C_mstrRdBufSize
 578 02e4 00000000 		.word	I2C_mstrRdBufIndex
 579 02e8 08030740 		.word	1074201352
 580 02ec 60000740 		.word	1074200672
 581 02f0 FFFEFFFF 		.word	-257
 582 02f4 00000000 		.word	I2C_mstrRdBufPtr
 583 02f8 40030740 		.word	1074201408
 584 02fc 68000740 		.word	1074200680
 585 0300 ED0F0000 		.word	4077
 586 0304 C00F0740 		.word	1074204608
 587 0308 00000000 		.word	I2C_mstrWrBufIndexTmp
 588 030c 08020740 		.word	1074201096
 589 0310 00000000 		.word	I2C_mstrWrBufIndex
 590 0314 04020740 		.word	1074201092
 591 0318 FFFFFEFF 		.word	-65537
 592 031c 8C0F0740 		.word	1074204556
 593 0320 00000000 		.word	I2C_mstrWrBufPtr
 594 0324 40020740 		.word	1074201152
 595 0328 F3070000 		.word	2035
 596 032c 800F0740 		.word	1074204544
 597 0330 C80F0740 		.word	1074204616
 598 0334 00000000 		.word	I2C_mstrControl
 599 0338 64000740 		.word	1074200676
 600 033c 00000740 		.word	1074200576
 601 0340 FF5FFFFF 		.word	-40961
 602 0344 FFFCFFFF 		.word	-769
 603 0348 FF0F0000 		.word	4095
 604 034c 400F0740 		.word	1074204480
 605 0350 17030000 		.word	791
 606              		.cfi_endproc
 607              	.LFE0:
 608              		.size	I2C_I2C_ISR, .-I2C_I2C_ISR
 609              		.text
 610              	.Letext0:
 611              		.file 2 "Generated_Source\\PSoC4/cytypes.h"
 612              		.file 3 ".\\Generated_Source\\PSoC4\\I2C_PVT.h"
 613              		.file 4 ".\\Generated_Source\\PSoC4\\I2C_I2C_PVT.h"
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 27


 614              		.section	.debug_info,"",%progbits
 615              	.Ldebug_info0:
 616 0000 86010000 		.4byte	0x186
 617 0004 0400     		.2byte	0x4
 618 0006 00000000 		.4byte	.Ldebug_abbrev0
 619 000a 04       		.byte	0x4
 620 000b 01       		.uleb128 0x1
 621 000c 06000000 		.4byte	.LASF31
 622 0010 01       		.byte	0x1
 623 0011 67020000 		.4byte	.LASF32
 624 0015 0D010000 		.4byte	.LASF33
 625 0019 00000000 		.4byte	.Ldebug_ranges0+0
 626 001d 00000000 		.4byte	0
 627 0021 00000000 		.4byte	.Ldebug_line0
 628 0025 02       		.uleb128 0x2
 629 0026 01       		.byte	0x1
 630 0027 06       		.byte	0x6
 631 0028 F3000000 		.4byte	.LASF0
 632 002c 02       		.uleb128 0x2
 633 002d 01       		.byte	0x1
 634 002e 08       		.byte	0x8
 635 002f FF000000 		.4byte	.LASF1
 636 0033 02       		.uleb128 0x2
 637 0034 02       		.byte	0x2
 638 0035 05       		.byte	0x5
 639 0036 EF010000 		.4byte	.LASF2
 640 003a 02       		.uleb128 0x2
 641 003b 02       		.byte	0x2
 642 003c 07       		.byte	0x7
 643 003d A5000000 		.4byte	.LASF3
 644 0041 02       		.uleb128 0x2
 645 0042 04       		.byte	0x4
 646 0043 05       		.byte	0x5
 647 0044 2F020000 		.4byte	.LASF4
 648 0048 02       		.uleb128 0x2
 649 0049 04       		.byte	0x4
 650 004a 07       		.byte	0x7
 651 004b 4D010000 		.4byte	.LASF5
 652 004f 02       		.uleb128 0x2
 653 0050 08       		.byte	0x8
 654 0051 05       		.byte	0x5
 655 0052 DC010000 		.4byte	.LASF6
 656 0056 02       		.uleb128 0x2
 657 0057 08       		.byte	0x8
 658 0058 07       		.byte	0x7
 659 0059 AF010000 		.4byte	.LASF7
 660 005d 03       		.uleb128 0x3
 661 005e 04       		.byte	0x4
 662 005f 05       		.byte	0x5
 663 0060 696E7400 		.ascii	"int\000"
 664 0064 02       		.uleb128 0x2
 665 0065 04       		.byte	0x4
 666 0066 07       		.byte	0x7
 667 0067 A2010000 		.4byte	.LASF8
 668 006b 04       		.uleb128 0x4
 669 006c 69010000 		.4byte	.LASF9
 670 0070 02       		.byte	0x2
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 28


 671 0071 C2       		.byte	0xc2
 672 0072 2C000000 		.4byte	0x2c
 673 0076 04       		.uleb128 0x4
 674 0077 82010000 		.4byte	.LASF10
 675 007b 02       		.byte	0x2
 676 007c C3       		.byte	0xc3
 677 007d 3A000000 		.4byte	0x3a
 678 0081 04       		.uleb128 0x4
 679 0082 89010000 		.4byte	.LASF11
 680 0086 02       		.byte	0x2
 681 0087 C4       		.byte	0xc4
 682 0088 48000000 		.4byte	0x48
 683 008c 02       		.uleb128 0x2
 684 008d 04       		.byte	0x4
 685 008e 04       		.byte	0x4
 686 008f ED000000 		.4byte	.LASF12
 687 0093 02       		.uleb128 0x2
 688 0094 08       		.byte	0x8
 689 0095 04       		.byte	0x4
 690 0096 7B010000 		.4byte	.LASF13
 691 009a 02       		.uleb128 0x2
 692 009b 01       		.byte	0x1
 693 009c 08       		.byte	0x8
 694 009d EA010000 		.4byte	.LASF14
 695 00a1 05       		.uleb128 0x5
 696 00a2 6B000000 		.4byte	0x6b
 697 00a6 05       		.uleb128 0x5
 698 00a7 76000000 		.4byte	0x76
 699 00ab 06       		.uleb128 0x6
 700 00ac 00000000 		.4byte	.LASF15
 701 00b0 02       		.byte	0x2
 702 00b1 6E01     		.2byte	0x16e
 703 00b3 B7000000 		.4byte	0xb7
 704 00b7 05       		.uleb128 0x5
 705 00b8 81000000 		.4byte	0x81
 706 00bc 06       		.uleb128 0x6
 707 00bd C6010000 		.4byte	.LASF16
 708 00c1 02       		.byte	0x2
 709 00c2 7E01     		.2byte	0x17e
 710 00c4 C8000000 		.4byte	0xc8
 711 00c8 07       		.uleb128 0x7
 712 00c9 04       		.byte	0x4
 713 00ca CE000000 		.4byte	0xce
 714 00ce 08       		.uleb128 0x8
 715 00cf 02       		.uleb128 0x2
 716 00d0 04       		.byte	0x4
 717 00d1 07       		.byte	0x7
 718 00d2 D3010000 		.4byte	.LASF17
 719 00d6 09       		.uleb128 0x9
 720 00d7 6F010000 		.4byte	.LASF34
 721 00db 01       		.byte	0x1
 722 00dc 25       		.byte	0x25
 723 00dd 00000000 		.4byte	.LFB0
 724 00e1 54030000 		.4byte	.LFE0-.LFB0
 725 00e5 01       		.uleb128 0x1
 726 00e6 9C       		.byte	0x9c
 727 00e7 0A010000 		.4byte	0x10a
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 29


 728 00eb 0A       		.uleb128 0xa
 729 00ec 5F010000 		.4byte	.LASF18
 730 00f0 01       		.byte	0x1
 731 00f1 27       		.byte	0x27
 732 00f2 81000000 		.4byte	0x81
 733 00f6 00000000 		.4byte	.LLST0
 734 00fa 0A       		.uleb128 0xa
 735 00fb B8000000 		.4byte	.LASF19
 736 00ff 01       		.byte	0x1
 737 0100 28       		.byte	0x28
 738 0101 81000000 		.4byte	0x81
 739 0105 2A000000 		.4byte	.LLST1
 740 0109 00       		.byte	0
 741 010a 0B       		.uleb128 0xb
 742 010b C4000000 		.4byte	.LASF20
 743 010f 03       		.byte	0x3
 744 0110 3A       		.byte	0x3a
 745 0111 BC000000 		.4byte	0xbc
 746 0115 0B       		.uleb128 0xb
 747 0116 38020000 		.4byte	.LASF21
 748 011a 04       		.byte	0x4
 749 011b 1D       		.byte	0x1d
 750 011c A1000000 		.4byte	0xa1
 751 0120 0B       		.uleb128 0xb
 752 0121 F9010000 		.4byte	.LASF22
 753 0125 04       		.byte	0x4
 754 0126 30       		.byte	0x30
 755 0127 A6000000 		.4byte	0xa6
 756 012b 0B       		.uleb128 0xb
 757 012c 8E020000 		.4byte	.LASF23
 758 0130 04       		.byte	0x4
 759 0131 31       		.byte	0x31
 760 0132 A1000000 		.4byte	0xa1
 761 0136 0B       		.uleb128 0xb
 762 0137 08020000 		.4byte	.LASF24
 763 013b 04       		.byte	0x4
 764 013c 34       		.byte	0x34
 765 013d 41010000 		.4byte	0x141
 766 0141 07       		.uleb128 0x7
 767 0142 04       		.byte	0x4
 768 0143 A1000000 		.4byte	0xa1
 769 0147 0B       		.uleb128 0xb
 770 0148 90010000 		.4byte	.LASF25
 771 014c 04       		.byte	0x4
 772 014d 35       		.byte	0x35
 773 014e B7000000 		.4byte	0xb7
 774 0152 0B       		.uleb128 0xb
 775 0153 DA000000 		.4byte	.LASF26
 776 0157 04       		.byte	0x4
 777 0158 36       		.byte	0x36
 778 0159 B7000000 		.4byte	0xb7
 779 015d 0B       		.uleb128 0xb
 780 015e 94000000 		.4byte	.LASF27
 781 0162 04       		.byte	0x4
 782 0163 39       		.byte	0x39
 783 0164 41010000 		.4byte	0x141
 784 0168 0B       		.uleb128 0xb
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 30


 785 0169 55020000 		.4byte	.LASF28
 786 016d 04       		.byte	0x4
 787 016e 3A       		.byte	0x3a
 788 016f B7000000 		.4byte	0xb7
 789 0173 0B       		.uleb128 0xb
 790 0174 42020000 		.4byte	.LASF29
 791 0178 04       		.byte	0x4
 792 0179 3B       		.byte	0x3b
 793 017a B7000000 		.4byte	0xb7
 794 017e 0B       		.uleb128 0xb
 795 017f 19020000 		.4byte	.LASF30
 796 0183 04       		.byte	0x4
 797 0184 3C       		.byte	0x3c
 798 0185 B7000000 		.4byte	0xb7
 799 0189 00       		.byte	0
 800              		.section	.debug_abbrev,"",%progbits
 801              	.Ldebug_abbrev0:
 802 0000 01       		.uleb128 0x1
 803 0001 11       		.uleb128 0x11
 804 0002 01       		.byte	0x1
 805 0003 25       		.uleb128 0x25
 806 0004 0E       		.uleb128 0xe
 807 0005 13       		.uleb128 0x13
 808 0006 0B       		.uleb128 0xb
 809 0007 03       		.uleb128 0x3
 810 0008 0E       		.uleb128 0xe
 811 0009 1B       		.uleb128 0x1b
 812 000a 0E       		.uleb128 0xe
 813 000b 55       		.uleb128 0x55
 814 000c 17       		.uleb128 0x17
 815 000d 11       		.uleb128 0x11
 816 000e 01       		.uleb128 0x1
 817 000f 10       		.uleb128 0x10
 818 0010 17       		.uleb128 0x17
 819 0011 00       		.byte	0
 820 0012 00       		.byte	0
 821 0013 02       		.uleb128 0x2
 822 0014 24       		.uleb128 0x24
 823 0015 00       		.byte	0
 824 0016 0B       		.uleb128 0xb
 825 0017 0B       		.uleb128 0xb
 826 0018 3E       		.uleb128 0x3e
 827 0019 0B       		.uleb128 0xb
 828 001a 03       		.uleb128 0x3
 829 001b 0E       		.uleb128 0xe
 830 001c 00       		.byte	0
 831 001d 00       		.byte	0
 832 001e 03       		.uleb128 0x3
 833 001f 24       		.uleb128 0x24
 834 0020 00       		.byte	0
 835 0021 0B       		.uleb128 0xb
 836 0022 0B       		.uleb128 0xb
 837 0023 3E       		.uleb128 0x3e
 838 0024 0B       		.uleb128 0xb
 839 0025 03       		.uleb128 0x3
 840 0026 08       		.uleb128 0x8
 841 0027 00       		.byte	0
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 31


 842 0028 00       		.byte	0
 843 0029 04       		.uleb128 0x4
 844 002a 16       		.uleb128 0x16
 845 002b 00       		.byte	0
 846 002c 03       		.uleb128 0x3
 847 002d 0E       		.uleb128 0xe
 848 002e 3A       		.uleb128 0x3a
 849 002f 0B       		.uleb128 0xb
 850 0030 3B       		.uleb128 0x3b
 851 0031 0B       		.uleb128 0xb
 852 0032 49       		.uleb128 0x49
 853 0033 13       		.uleb128 0x13
 854 0034 00       		.byte	0
 855 0035 00       		.byte	0
 856 0036 05       		.uleb128 0x5
 857 0037 35       		.uleb128 0x35
 858 0038 00       		.byte	0
 859 0039 49       		.uleb128 0x49
 860 003a 13       		.uleb128 0x13
 861 003b 00       		.byte	0
 862 003c 00       		.byte	0
 863 003d 06       		.uleb128 0x6
 864 003e 16       		.uleb128 0x16
 865 003f 00       		.byte	0
 866 0040 03       		.uleb128 0x3
 867 0041 0E       		.uleb128 0xe
 868 0042 3A       		.uleb128 0x3a
 869 0043 0B       		.uleb128 0xb
 870 0044 3B       		.uleb128 0x3b
 871 0045 05       		.uleb128 0x5
 872 0046 49       		.uleb128 0x49
 873 0047 13       		.uleb128 0x13
 874 0048 00       		.byte	0
 875 0049 00       		.byte	0
 876 004a 07       		.uleb128 0x7
 877 004b 0F       		.uleb128 0xf
 878 004c 00       		.byte	0
 879 004d 0B       		.uleb128 0xb
 880 004e 0B       		.uleb128 0xb
 881 004f 49       		.uleb128 0x49
 882 0050 13       		.uleb128 0x13
 883 0051 00       		.byte	0
 884 0052 00       		.byte	0
 885 0053 08       		.uleb128 0x8
 886 0054 15       		.uleb128 0x15
 887 0055 00       		.byte	0
 888 0056 27       		.uleb128 0x27
 889 0057 19       		.uleb128 0x19
 890 0058 00       		.byte	0
 891 0059 00       		.byte	0
 892 005a 09       		.uleb128 0x9
 893 005b 2E       		.uleb128 0x2e
 894 005c 01       		.byte	0x1
 895 005d 3F       		.uleb128 0x3f
 896 005e 19       		.uleb128 0x19
 897 005f 03       		.uleb128 0x3
 898 0060 0E       		.uleb128 0xe
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 32


 899 0061 3A       		.uleb128 0x3a
 900 0062 0B       		.uleb128 0xb
 901 0063 3B       		.uleb128 0x3b
 902 0064 0B       		.uleb128 0xb
 903 0065 27       		.uleb128 0x27
 904 0066 19       		.uleb128 0x19
 905 0067 11       		.uleb128 0x11
 906 0068 01       		.uleb128 0x1
 907 0069 12       		.uleb128 0x12
 908 006a 06       		.uleb128 0x6
 909 006b 40       		.uleb128 0x40
 910 006c 18       		.uleb128 0x18
 911 006d 9642     		.uleb128 0x2116
 912 006f 19       		.uleb128 0x19
 913 0070 01       		.uleb128 0x1
 914 0071 13       		.uleb128 0x13
 915 0072 00       		.byte	0
 916 0073 00       		.byte	0
 917 0074 0A       		.uleb128 0xa
 918 0075 34       		.uleb128 0x34
 919 0076 00       		.byte	0
 920 0077 03       		.uleb128 0x3
 921 0078 0E       		.uleb128 0xe
 922 0079 3A       		.uleb128 0x3a
 923 007a 0B       		.uleb128 0xb
 924 007b 3B       		.uleb128 0x3b
 925 007c 0B       		.uleb128 0xb
 926 007d 49       		.uleb128 0x49
 927 007e 13       		.uleb128 0x13
 928 007f 02       		.uleb128 0x2
 929 0080 17       		.uleb128 0x17
 930 0081 00       		.byte	0
 931 0082 00       		.byte	0
 932 0083 0B       		.uleb128 0xb
 933 0084 34       		.uleb128 0x34
 934 0085 00       		.byte	0
 935 0086 03       		.uleb128 0x3
 936 0087 0E       		.uleb128 0xe
 937 0088 3A       		.uleb128 0x3a
 938 0089 0B       		.uleb128 0xb
 939 008a 3B       		.uleb128 0x3b
 940 008b 0B       		.uleb128 0xb
 941 008c 49       		.uleb128 0x49
 942 008d 13       		.uleb128 0x13
 943 008e 3F       		.uleb128 0x3f
 944 008f 19       		.uleb128 0x19
 945 0090 3C       		.uleb128 0x3c
 946 0091 19       		.uleb128 0x19
 947 0092 00       		.byte	0
 948 0093 00       		.byte	0
 949 0094 00       		.byte	0
 950              		.section	.debug_loc,"",%progbits
 951              	.Ldebug_loc0:
 952              	.LLST0:
 953 0000 08010000 		.4byte	.LVL17
 954 0004 14010000 		.4byte	.LVL19
 955 0008 0100     		.2byte	0x1
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 33


 956 000a 52       		.byte	0x52
 957 000b 1A010000 		.4byte	.LVL20
 958 000f 1C010000 		.4byte	.LVL21
 959 0013 0200     		.2byte	0x2
 960 0015 38       		.byte	0x38
 961 0016 9F       		.byte	0x9f
 962 0017 1E010000 		.4byte	.LVL22
 963 001b 3C010000 		.4byte	.LVL24
 964 001f 0100     		.2byte	0x1
 965 0021 52       		.byte	0x52
 966 0022 00000000 		.4byte	0
 967 0026 00000000 		.4byte	0
 968              	.LLST1:
 969 002a 00000000 		.4byte	.LVL0
 970 002e 22000000 		.4byte	.LVL2
 971 0032 0200     		.2byte	0x2
 972 0034 30       		.byte	0x30
 973 0035 9F       		.byte	0x9f
 974 0036 26000000 		.4byte	.LVL3
 975 003a 3C000000 		.4byte	.LVL4
 976 003e 0200     		.2byte	0x2
 977 0040 30       		.byte	0x30
 978 0041 9F       		.byte	0x9f
 979 0042 3C000000 		.4byte	.LVL4
 980 0046 3E000000 		.4byte	.LVL5
 981 004a 0200     		.2byte	0x2
 982 004c 31       		.byte	0x31
 983 004d 9F       		.byte	0x9f
 984 004e 3E000000 		.4byte	.LVL5
 985 0052 48000000 		.4byte	.LVL6
 986 0056 0100     		.2byte	0x1
 987 0058 51       		.byte	0x51
 988 0059 50000000 		.4byte	.LVL7
 989 005d 52000000 		.4byte	.LVL8
 990 0061 0200     		.2byte	0x2
 991 0063 31       		.byte	0x31
 992 0064 9F       		.byte	0x9f
 993 0065 52000000 		.4byte	.LVL8
 994 0069 56000000 		.4byte	.LVL9
 995 006d 0100     		.2byte	0x1
 996 006f 51       		.byte	0x51
 997 0070 6E000000 		.4byte	.LVL10
 998 0074 82000000 		.4byte	.LVL11
 999 0078 0100     		.2byte	0x1
 1000 007a 51       		.byte	0x51
 1001 007b 9A000000 		.4byte	.LVL12
 1002 007f AC000000 		.4byte	.LVL13
 1003 0083 0100     		.2byte	0x1
 1004 0085 51       		.byte	0x51
 1005 0086 B8000000 		.4byte	.LVL14
 1006 008a BC000000 		.4byte	.LVL15
 1007 008e 0200     		.2byte	0x2
 1008 0090 31       		.byte	0x31
 1009 0091 9F       		.byte	0x9f
 1010 0092 BC000000 		.4byte	.LVL15
 1011 0096 12010000 		.4byte	.LVL18
 1012 009a 0100     		.2byte	0x1
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 34


 1013 009c 51       		.byte	0x51
 1014 009d 1A010000 		.4byte	.LVL20
 1015 00a1 1C010000 		.4byte	.LVL21
 1016 00a5 0200     		.2byte	0x2
 1017 00a7 31       		.byte	0x31
 1018 00a8 9F       		.byte	0x9f
 1019 00a9 1E010000 		.4byte	.LVL22
 1020 00ad 7C010000 		.4byte	.LVL26
 1021 00b1 0100     		.2byte	0x1
 1022 00b3 51       		.byte	0x51
 1023 00b4 BC010000 		.4byte	.LVL27
 1024 00b8 14020000 		.4byte	.LVL28
 1025 00bc 0100     		.2byte	0x1
 1026 00be 51       		.byte	0x51
 1027 00bf 18020000 		.4byte	.LVL29
 1028 00c3 1A020000 		.4byte	.LVL30
 1029 00c7 0200     		.2byte	0x2
 1030 00c9 31       		.byte	0x31
 1031 00ca 9F       		.byte	0x9f
 1032 00cb 1A020000 		.4byte	.LVL30
 1033 00cf 1E020000 		.4byte	.LVL31
 1034 00d3 0100     		.2byte	0x1
 1035 00d5 51       		.byte	0x51
 1036 00d6 66020000 		.4byte	.LVL32
 1037 00da 68020000 		.4byte	.LVL33
 1038 00de 0100     		.2byte	0x1
 1039 00e0 51       		.byte	0x51
 1040 00e1 00000000 		.4byte	0
 1041 00e5 00000000 		.4byte	0
 1042              		.section	.debug_aranges,"",%progbits
 1043 0000 1C000000 		.4byte	0x1c
 1044 0004 0200     		.2byte	0x2
 1045 0006 00000000 		.4byte	.Ldebug_info0
 1046 000a 04       		.byte	0x4
 1047 000b 00       		.byte	0
 1048 000c 0000     		.2byte	0
 1049 000e 0000     		.2byte	0
 1050 0010 00000000 		.4byte	.LFB0
 1051 0014 54030000 		.4byte	.LFE0-.LFB0
 1052 0018 00000000 		.4byte	0
 1053 001c 00000000 		.4byte	0
 1054              		.section	.debug_ranges,"",%progbits
 1055              	.Ldebug_ranges0:
 1056 0000 00000000 		.4byte	.LFB0
 1057 0004 54030000 		.4byte	.LFE0
 1058 0008 00000000 		.4byte	0
 1059 000c 00000000 		.4byte	0
 1060              		.section	.debug_line,"",%progbits
 1061              	.Ldebug_line0:
 1062 0000 58010000 		.section	.debug_str,"MS",%progbits,1
 1062      02007F00 
 1062      00000201 
 1062      FB0E0D00 
 1062      01010101 
 1063              	.LASF15:
 1064 0000 72656733 		.ascii	"reg32\000"
 1064      3200
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 35


 1065              	.LASF31:
 1066 0006 474E5520 		.ascii	"GNU C 4.9.3 20150303 (release) [ARM/embedded-4_9-br"
 1066      4320342E 
 1066      392E3320 
 1066      32303135 
 1066      30333033 
 1067 0039 616E6368 		.ascii	"anch revision 221220] -mcpu=cortex-m0 -mthumb -g -O"
 1067      20726576 
 1067      6973696F 
 1067      6E203232 
 1067      31323230 
 1068 006c 73202D66 		.ascii	"s -ffunction-sections -ffat-lto-objects\000"
 1068      66756E63 
 1068      74696F6E 
 1068      2D736563 
 1068      74696F6E 
 1069              	.LASF27:
 1070 0094 4932435F 		.ascii	"I2C_mstrWrBufPtr\000"
 1070      6D737472 
 1070      57724275 
 1070      66507472 
 1070      00
 1071              	.LASF3:
 1072 00a5 73686F72 		.ascii	"short unsigned int\000"
 1072      7420756E 
 1072      7369676E 
 1072      65642069 
 1072      6E7400
 1073              	.LASF19:
 1074 00b8 656E6454 		.ascii	"endTransfer\000"
 1074      72616E73 
 1074      66657200 
 1075              	.LASF20:
 1076 00c4 4932435F 		.ascii	"I2C_customIntrHandler\000"
 1076      63757374 
 1076      6F6D496E 
 1076      74724861 
 1076      6E646C65 
 1077              	.LASF26:
 1078 00da 4932435F 		.ascii	"I2C_mstrRdBufIndex\000"
 1078      6D737472 
 1078      52644275 
 1078      66496E64 
 1078      657800
 1079              	.LASF12:
 1080 00ed 666C6F61 		.ascii	"float\000"
 1080      7400
 1081              	.LASF0:
 1082 00f3 7369676E 		.ascii	"signed char\000"
 1082      65642063 
 1082      68617200 
 1083              	.LASF1:
 1084 00ff 756E7369 		.ascii	"unsigned char\000"
 1084      676E6564 
 1084      20636861 
 1084      7200
 1085              	.LASF33:
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 36


 1086 010d 433A5C55 		.ascii	"C:\\Users\\Vit\\Documents\\PSoC Creator\\SensorTest"
 1086      73657273 
 1086      5C566974 
 1086      5C446F63 
 1086      756D656E 
 1087 013b 5C53656E 		.ascii	"\\SensorTest.cydsn\000"
 1087      736F7254 
 1087      6573742E 
 1087      63796473 
 1087      6E00
 1088              	.LASF5:
 1089 014d 6C6F6E67 		.ascii	"long unsigned int\000"
 1089      20756E73 
 1089      69676E65 
 1089      6420696E 
 1089      7400
 1090              	.LASF18:
 1091 015f 64696666 		.ascii	"diffCount\000"
 1091      436F756E 
 1091      7400
 1092              	.LASF9:
 1093 0169 75696E74 		.ascii	"uint8\000"
 1093      3800
 1094              	.LASF34:
 1095 016f 4932435F 		.ascii	"I2C_I2C_ISR\000"
 1095      4932435F 
 1095      49535200 
 1096              	.LASF13:
 1097 017b 646F7562 		.ascii	"double\000"
 1097      6C6500
 1098              	.LASF10:
 1099 0182 75696E74 		.ascii	"uint16\000"
 1099      313600
 1100              	.LASF11:
 1101 0189 75696E74 		.ascii	"uint32\000"
 1101      333200
 1102              	.LASF25:
 1103 0190 4932435F 		.ascii	"I2C_mstrRdBufSize\000"
 1103      6D737472 
 1103      52644275 
 1103      6653697A 
 1103      6500
 1104              	.LASF8:
 1105 01a2 756E7369 		.ascii	"unsigned int\000"
 1105      676E6564 
 1105      20696E74 
 1105      00
 1106              	.LASF7:
 1107 01af 6C6F6E67 		.ascii	"long long unsigned int\000"
 1107      206C6F6E 
 1107      6720756E 
 1107      7369676E 
 1107      65642069 
 1108              	.LASF16:
 1109 01c6 63796973 		.ascii	"cyisraddress\000"
 1109      72616464 
 1109      72657373 
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 37


 1109      00
 1110              	.LASF17:
 1111 01d3 73697A65 		.ascii	"sizetype\000"
 1111      74797065 
 1111      00
 1112              	.LASF6:
 1113 01dc 6C6F6E67 		.ascii	"long long int\000"
 1113      206C6F6E 
 1113      6720696E 
 1113      7400
 1114              	.LASF14:
 1115 01ea 63686172 		.ascii	"char\000"
 1115      00
 1116              	.LASF2:
 1117 01ef 73686F72 		.ascii	"short int\000"
 1117      7420696E 
 1117      7400
 1118              	.LASF22:
 1119 01f9 4932435F 		.ascii	"I2C_mstrStatus\000"
 1119      6D737472 
 1119      53746174 
 1119      757300
 1120              	.LASF24:
 1121 0208 4932435F 		.ascii	"I2C_mstrRdBufPtr\000"
 1121      6D737472 
 1121      52644275 
 1121      66507472 
 1121      00
 1122              	.LASF30:
 1123 0219 4932435F 		.ascii	"I2C_mstrWrBufIndexTmp\000"
 1123      6D737472 
 1123      57724275 
 1123      66496E64 
 1123      6578546D 
 1124              	.LASF4:
 1125 022f 6C6F6E67 		.ascii	"long int\000"
 1125      20696E74 
 1125      00
 1126              	.LASF21:
 1127 0238 4932435F 		.ascii	"I2C_state\000"
 1127      73746174 
 1127      6500
 1128              	.LASF29:
 1129 0242 4932435F 		.ascii	"I2C_mstrWrBufIndex\000"
 1129      6D737472 
 1129      57724275 
 1129      66496E64 
 1129      657800
 1130              	.LASF28:
 1131 0255 4932435F 		.ascii	"I2C_mstrWrBufSize\000"
 1131      6D737472 
 1131      57724275 
 1131      6653697A 
 1131      6500
 1132              	.LASF32:
 1133 0267 2E5C4765 		.ascii	".\\Generated_Source\\PSoC4\\I2C_I2C_INT.c\000"
 1133      6E657261 
ARM GAS  C:\Users\Vit\AppData\Local\Temp\ccbkt1sM.s 			page 38


 1133      7465645F 
 1133      536F7572 
 1133      63655C50 
 1134              	.LASF23:
 1135 028e 4932435F 		.ascii	"I2C_mstrControl\000"
 1135      6D737472 
 1135      436F6E74 
 1135      726F6C00 
 1136              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.9.3 20150303 (release) [ARM/embedded-4_9-br
